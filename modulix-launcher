#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage:
  modulix-launcher --inventory-dir <PATH> services <wunderbox|aap> [--rebuild] [--playbook <PATH>] [ansible args...]
  modulix-launcher --inventory-dir <PATH> toolbox shell

Notes:
  --inventory-dir <PATH> sets the inventories root directory mounted into the runtime.
  -i/--inventory in [ansible args...] selects the concrete Ansible inventory file.
  Execution mode is nested-only with fixed host preload:
  host always exports RUN_EE_IMAGE and toolbox always loads it before run.
USAGE
}

die() {
  echo "Error: $*" >&2
  exit 1
}

abs_path() {
  local p="$1"
  [[ "$p" == /* ]] || p="$PWD/$p"
  readlink -f -- "$p"
}

runner_path() {
  local p
  p="$(abs_path "$1")"
  case "$p" in
    "$PWD_ABS") echo "/runner/project" ;;
    "$PWD_ABS"/*) echo "/runner/project/${p#"$PWD_ABS"/}" ;;
    *) die "path must be inside current directory ($PWD_ABS): $1" ;;
  esac
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  usage
  exit 0
fi

PWD_ABS="$(readlink -f -- "$PWD")"
INVENTORY_DIR=""

case "${1:-}" in
  --inventory-dir)
    [[ -n "${2:-}" ]] || {
      usage
      die "missing required ${1} <PATH>"
    }
    INVENTORY_DIR="$(abs_path "$2")"
    shift 2
    ;;
  --inventory-dir=*)
    local_inv="${1#*=}"
    [[ -n "$local_inv" ]] || {
      usage
      die "${1%%=*} requires a non-empty value"
    }
    INVENTORY_DIR="$(abs_path "$local_inv")"
    shift
    ;;
  *)
    usage
    die "missing required --inventory-dir <PATH>"
    ;;
esac

case "$INVENTORY_DIR" in
  "$PWD_ABS"|"$PWD_ABS"/*) ;;
  *) die "--inventory-dir must be inside current directory ($PWD_ABS): $INVENTORY_DIR" ;;
esac
[[ -d "$INVENTORY_DIR" ]] || die "--inventory-dir is not a directory: $INVENTORY_DIR"

RUN_EE_IMAGE="${RUN_EE_IMAGE:-quay.io/l-it/ee-wunder-ansible-ubi9-certified:v1.11.6}"
RUN_TOOLBOX_IMAGE="${RUN_TOOLBOX_IMAGE:-quay.io/l-it/ee-wunder-toolbox-ubi9:v1.7.2}"
VAULT_PASS_FILE="$(abs_path "${VAULT_PASS_FILE:-$PWD_ABS/.vault-pass.txt}")"
RUN_SKIP_CERT_CHECK="${RUN_SKIP_CERT_CHECK:-false}"

case "$RUN_SKIP_CERT_CHECK" in
  true|false) ;;
  *) die "RUN_SKIP_CERT_CHECK must be true or false (got: $RUN_SKIP_CERT_CHECK)" ;;
esac

case "$VAULT_PASS_FILE" in
  "$PWD_ABS"|"$PWD_ABS"/*) ;;
  *) die "VAULT_PASS_FILE must be inside current directory ($PWD_ABS): $VAULT_PASS_FILE" ;;
esac
[[ -f "$VAULT_PASS_FILE" && -r "$VAULT_PASS_FILE" && -s "$VAULT_PASS_FILE" ]] || {
  die "required file missing or unreadable: $VAULT_PASS_FILE"
}

RUNNER_INVENTORY_DIR="$(runner_path "$INVENTORY_DIR")"
RUNNER_VAULT_PASS_FILE="$(runner_path "$VAULT_PASS_FILE")"
SSH_AUTH_SOCK_HOST=""

ensure_image_available_on_host() {
  local image="$1"
  local pull_args=()
  if podman image exists "$image" >/dev/null 2>&1; then
    return 0
  fi

  if [[ "$image" == localhost/* ]]; then
    die "local image not found: $image"
  fi

  if [[ "$RUN_SKIP_CERT_CHECK" == "true" ]]; then
    pull_args+=( --tls-verify=false )
  fi

  podman pull "${pull_args[@]}" "$image" >/dev/null
}

require_ssh_agent() {
  local candidate=""
  [[ -n "${SSH_AUTH_SOCK:-}" ]] || die "SSH_AUTH_SOCK is not set. Start ssh-agent and load key(s) with ssh-add."

  candidate="$(readlink -f -- "$SSH_AUTH_SOCK" 2>/dev/null || true)"
  if [[ -n "$candidate" && -S "$candidate" ]]; then
    SSH_AUTH_SOCK_HOST="$candidate"
    return
  fi

  if [[ -S "$SSH_AUTH_SOCK" ]]; then
    SSH_AUTH_SOCK_HOST="$SSH_AUTH_SOCK"
    return
  fi

  die "SSH_AUTH_SOCK is not a valid socket: $SSH_AUTH_SOCK"
}

run_toolbox() {
  local interactive="$1"
  shift

  local tty=()
  [[ "$interactive" == true ]] && tty=( -it )
  local ee_volume_mounts="${ANSIBLE_NAVIGATOR_EXECUTION_ENVIRONMENT_VOLUME_MOUNTS:-/opt/modulix:/opt/modulix:Z}"

  local envs=(
    -e HOME=/runner/project
    -e ANSIBLE_TOOLBOX_NAV_EE_ENABLED=true
    -e "ANSIBLE_TOOLBOX_NAV_EE_IMAGE=$RUN_EE_IMAGE"
    -e "ANSIBLE_TOOLBOX_NAV_SKIP_CERT_CHECK=$RUN_SKIP_CERT_CHECK"
    -e ANSIBLE_TOOLBOX_AUTO_COLLECTIONS=false
    -e "ANSIBLE_VAULT_PASSWORD_FILE=$RUNNER_VAULT_PASS_FILE"
    -e "ANSIBLE_NAVIGATOR_EXECUTION_ENVIRONMENT_VOLUME_MOUNTS=$ee_volume_mounts"
  )
  envs+=( -e ANSIBLE_TOOLBOX_NAV_PULL_POLICY=never )
  [[ -n "${VAULT_TOKEN:-}" ]] && envs+=( -e "VAULT_TOKEN=${VAULT_TOKEN}" )
  local socket_mount=()
  if [[ -n "$SSH_AUTH_SOCK_HOST" ]]; then
    envs+=( -e "SSH_AUTH_SOCK=$SSH_AUTH_SOCK_HOST" )
    socket_mount+=( -v "$SSH_AUTH_SOCK_HOST:$SSH_AUTH_SOCK_HOST" )
  fi

  podman run --rm "${tty[@]}" \
    --privileged \
    --security-opt label=disable \
    --user 0:0 \
    -w /runner/project \
    -v "$PWD_ABS:/runner/project:Z" \
    "${socket_mount[@]}" \
    "${envs[@]}" \
    "$RUN_TOOLBOX_IMAGE" \
    "$@"
}

rewrite_inventory_args() {
  local out=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -i|--inventory)
        [[ $# -ge 2 ]] || die "$1 requires a value"
        if [[ "$2" == inventories/* ]]; then
          out+=( "$1" "$RUNNER_INVENTORY_DIR/${2#inventories/}" )
        else
          out+=( "$1" "$2" )
        fi
        shift 2
        ;;
      --inventory=*)
        local inv="${1#*=}"
        if [[ "$inv" == inventories/* ]]; then
          out+=( "--inventory=$RUNNER_INVENTORY_DIR/${inv#inventories/}" )
        else
          out+=( "$1" )
        fi
        shift
        ;;
      *)
        out+=( "$1" )
        shift
        ;;
    esac
  done
  printf '%s\0' "${out[@]}"
}

run_services() {
  local service="$1"
  shift || true

  require_ssh_agent

  local rebuild=false
  local playbook_override=""
  local expect_playbook=false
  local args=()
  local a
  for a in "$@"; do
    if [[ "$expect_playbook" == true ]]; then
      playbook_override="$a"
      expect_playbook=false
      continue
    fi
    case "$a" in
      --rebuild|-r|rebuild) rebuild=true ;;
      --playbook|-p) expect_playbook=true ;;
      --playbook=*|-p=*)
        playbook_override="${a#*=}"
        [[ -n "$playbook_override" ]] || die "--playbook requires a non-empty value"
        ;;
      *) args+=( "$a" ) ;;
    esac
  done
  [[ "$expect_playbook" == false ]] || die "--playbook requires a value"

  local playbook=""
  case "$service" in
    wunderbox)
      if [[ "$rebuild" == true ]]; then
        playbook="/opt/modulix/ansible/playbooks/services/01-wunderbox-rebuild.yml"
      else
        playbook="/opt/modulix/ansible/playbooks/stage-2b/12-wunderbox.yml"
      fi
      ;;
    aap)
      if [[ "$rebuild" == true ]]; then
        playbook="/opt/modulix/ansible/playbooks/services/02-aap-rebuild.yml"
      else
        playbook="/opt/modulix/ansible/playbooks/stage-2b/13-aap.yml"
      fi
      ;;
    *) die "unsupported service '$service' (use: wunderbox | aap)" ;;
  esac

  if [[ -n "$playbook_override" ]]; then
    case "$playbook_override" in
      /*) playbook="$playbook_override" ;;
      playbooks/*) playbook="/opt/modulix/ansible/$playbook_override" ;;
      ansible/playbooks/*) playbook="/runner/project/$playbook_override" ;;
      *.yml|*.yaml) playbook="/opt/modulix/ansible/playbooks/$playbook_override" ;;
      *) die "invalid --playbook path '$playbook_override' (use absolute path, playbooks/..., ansible/playbooks/..., or <subpath>.yml)" ;;
    esac
  fi

  local has_inventory=false
  local has_limit=false
  for a in "${args[@]}"; do
    [[ "$a" == "-i" || "$a" == "--inventory" || "$a" == --inventory=* ]] && has_inventory=true
    [[ "$a" == "-l" || "$a" == "--limit" ]] && has_limit=true
  done
  [[ "$has_inventory" == true ]] || die "services mode requires ansible -i/--inventory <FILE> (separate from top-level --inventory-dir)"
  [[ "$has_limit" == true ]] || die "services mode requires -l/--limit (no environment-specific default host is assumed)"

  local run_args=()
  while IFS= read -r -d '' a; do
    run_args+=( "$a" )
  done < <(rewrite_inventory_args "${args[@]}")

  ensure_image_available_on_host "$RUN_EE_IMAGE"
  ensure_image_available_on_host "$RUN_TOOLBOX_IMAGE"

  local ee_archive=""
  local runner_ee_archive=""
  local cache_dir="$PWD_ABS/.modulix-launcher-cache"
  mkdir -p -- "$cache_dir"
  ee_archive="$(mktemp "$cache_dir/run-ee-image.XXXXXX.tar")"
  runner_ee_archive="$(runner_path "$ee_archive")"

  if ! podman save -o "$ee_archive" "$RUN_EE_IMAGE" >/dev/null; then
    rm -f -- "$ee_archive"
    die "failed to export run EE image from host store: $RUN_EE_IMAGE"
  fi

  if ! run_toolbox true bash -lc '
    set -euo pipefail
    ee_archive="$1"
    shift
    podman load -i "$ee_archive" >/dev/null
    exec ansible-nav-local run "$@"
  ' -- "$runner_ee_archive" "$playbook" "${run_args[@]}"; then
    rm -f -- "$ee_archive"
    return 1
  fi

  rm -f -- "$ee_archive"
}

run_toolbox_shell() {
  require_ssh_agent

  ensure_image_available_on_host "$RUN_EE_IMAGE"
  ensure_image_available_on_host "$RUN_TOOLBOX_IMAGE"

  local ee_archive=""
  local runner_ee_archive=""
  local cache_dir="$PWD_ABS/.modulix-launcher-cache"
  mkdir -p -- "$cache_dir"
  ee_archive="$(mktemp "$cache_dir/run-ee-image.XXXXXX.tar")"
  runner_ee_archive="$(runner_path "$ee_archive")"

  if ! podman save -o "$ee_archive" "$RUN_EE_IMAGE" >/dev/null; then
    rm -f -- "$ee_archive"
    die "failed to export run EE image from host store: $RUN_EE_IMAGE"
  fi

  if ! run_toolbox true bash -lc '
    set -euo pipefail
    ee_archive="$1"
    shift
    podman load -i "$ee_archive" >/dev/null
    exec /bin/bash
  ' -- "$runner_ee_archive"; then
    rm -f -- "$ee_archive"
    return 1
  fi

  rm -f -- "$ee_archive"
}

mode="${1:-}"
case "$mode" in
  services)
    service="${2:-wunderbox}"
    shift $(( $# >= 2 ? 2 : $# ))
    run_services "$service" "$@"
    ;;
  toolbox)
    sub="${2:-shell}"
    shift $(( $# >= 2 ? 2 : $# ))
    case "$sub" in
      shell) run_toolbox_shell "$@" ;;
      *) die "unsupported toolbox subcommand '$sub' (use: shell)" ;;
    esac
    ;;
  *)
    usage
    die "unsupported mode '$mode' (expected: services | toolbox)"
    ;;
esac
